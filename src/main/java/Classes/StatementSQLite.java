package Classes;

import java.sql.*;

public class StatementSQLite {

    //Refactor to avoid error> SQLException - org.sqlite.SQLiteException: [SQLITE_BUSY]  The database file is locked (database is locked)
    private Connection connect(){
        Connection connection;

        try {
            String url = "jdbc:sqlite:javasparkbocadb.db" ;
            connection = DriverManager.getConnection(url);
            System.out.println("Connection to SQLite has been established.");
        } catch (SQLException e) {
            e.printStackTrace();
            return null;
        }
        return connection;
    }

    public Boolean createTable(String sqlCommand){
        Connection connection = null;
        Statement statement = null;
        try {
            connection = this.connect();
            if (connection == null) {
                return false;
            }
            statement = connection.createStatement();
            statement.executeUpdate(sqlCommand);
            System.out.println("Table created.");
            return true;
        } catch (SQLException e1) {
            e1.printStackTrace();
            return false;
        } finally {
            try {
                if (statement != null) {
                    statement.close();
                }
                if (connection != null) {

                    connection.close();
                }
            } catch (SQLException e2) {
                e2.printStackTrace();
            }
        }
    }

    public Boolean prepareStatementTransactionProblem(Problem problem, String sqlCommand) {
        //A table of data representing a database result set, which is usually generated by executing a statement that queries the database.
        ResultSet resultSet = null;

        //A connection (session) with a specific database.
        Connection conn = null;

        //Creates a default PreparedStatement object that has the capability to retrieve auto-generated keys
        PreparedStatement preparedStatement = null;

        try {
            conn = this.connect();
            if (conn == null) {
                return false;
            }
            conn.setAutoCommit(false);
            //The constant indicating that generated keys should be made available for retrieval.
            preparedStatement = conn.prepareStatement(sqlCommand,Statement.RETURN_GENERATED_KEYS);
            /*You must supply values in place of the question mark placeholders (if there are any) before you can execute a PreparedStatement object.
            * The first argument for each of these setter methods specifies the question mark placeholder. */
            if(problem.problem != null){
                preparedStatement.setString(1, problem.problem);
            }
            if(problem.filename != null){
                preparedStatement.setString(2, problem.filename);
            }
            if(problem.lps != null){
                preparedStatement.setString(3, problem.lps);
            }
            //for INSERT, UPDATE or DELETE use the executeUpdate() method
            int rowAffected = preparedStatement.executeUpdate();
            resultSet = preparedStatement.getGeneratedKeys();

            if (rowAffected != 1) {
                conn.rollback();
                return false;
            } else {
                conn.commit();
            }

        } catch (SQLException e1) {
            try {
                if (conn != null) {
                    conn.rollback();
                    return false;
                }
            } catch (SQLException e2) {
                e2.printStackTrace();
            }
            e1.printStackTrace();
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
                if (preparedStatement != null) {
                    preparedStatement.close();
                }
                if (conn != null) {
                    conn.close();
                }
            } catch (SQLException e3) {
                e3.printStackTrace();
            }
        }
        return true;
    }

    public Boolean prepareStatementTransactionExpectedAnswer(ExpectedAnswer expectedAnswer, String sqlCommand) {
        //A table of data representing a database result set, which is usually generated by executing a statement that queries the database.
        ResultSet resultSet = null;

        //A connection (session) with a specific database.
        Connection conn = null;

        //Creates a default PreparedStatement object that has the capability to retrieve auto-generated keys
        PreparedStatement preparedStatement = null;

        try {
            conn = this.connect();
            if (conn == null) {
                return false;
            }
            conn.setAutoCommit(false);
            //The constant indicating that generated keys should be made available for retrieval.
            preparedStatement = conn.prepareStatement(sqlCommand,Statement.RETURN_GENERATED_KEYS);
            /*You must supply values in place of the question mark placeholders (if there are any) before you can execute a PreparedStatement object.
             * The first argument for each of these setter methods specifies the question mark placeholder. */
            if(expectedAnswer.inputFilename != null){
                preparedStatement.setString(1, expectedAnswer.inputFilename);
            }
            if(expectedAnswer.inputContent != null){
                preparedStatement.setString(2, expectedAnswer.inputContent);
            }
            if(expectedAnswer.outputFilename != null){
                preparedStatement.setString(3, expectedAnswer.outputFilename);
            }
            if(expectedAnswer.outputContent != null){
                preparedStatement.setString(4, expectedAnswer.outputContent);
            }
            if(expectedAnswer.problem != null){
                preparedStatement.setString(5, expectedAnswer.problem);
            }
            //for INSERT, UPDATE or DELETE use the executeUpdate() method
            int rowAffected = preparedStatement.executeUpdate();
            resultSet = preparedStatement.getGeneratedKeys();

            if (rowAffected != 1) {
                conn.rollback();
                return false;
            } else {
                conn.commit();
            }

        } catch (SQLException e1) {
            try {
                if (conn != null) {
                    conn.rollback();
                    return false;
                }
            } catch (SQLException e2) {
                e2.printStackTrace();
            }
            e1.printStackTrace();
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
                if (preparedStatement != null) {
                    preparedStatement.close();
                }
                if (conn != null) {
                    conn.close();
                }
            } catch (SQLException e3) {
                e3.printStackTrace();
            }
        }
        return true;
    }

    public ResultSet selectTable(String selectTable) throws SQLException {
        ResultSet resultSet;
        Connection con;
        Statement statement;
        try {
            con = this.connect();
            if (con == null) {
                return null;
            }
            statement = con.createStatement();
            //for SELECT use the executeQuery() method which returns the ResultSet
            resultSet = statement.executeQuery(selectTable);
            System.out.println("Select command executed.");
            return resultSet;

        } catch (SQLException e1) {
            e1.printStackTrace();
            return null;

        }
    }
}
